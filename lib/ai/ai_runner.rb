
require_relative "ai"  
require_relative "../gamelogic/gamestate"

### AI is ~80% generated by chatgpt ###

module AiRunner
  class << self
    # interne Zustände
    def reset!
      @ai_for           = { white: false,  black: false }   # P v P as standard
      @depth            = { white: 6,     black: 3 }
      @time_ms          = { white: 3600,   black: 600 }
      @move_delay_ms    = 250
      @busy             = false
      @next_think_at_ms = 0
    end

    # konfigurieren (optional in main überschreiben)
    def configure(ai_for: nil, depth: nil, time_ms: nil, move_delay_ms: nil)
      reset! unless defined?(@ai_for)
      @ai_for.merge!(ai_for) if ai_for
      @depth.merge!(depth)    if depth
      @time_ms.merge!(time_ms) if time_ms
      @move_delay_ms = move_delay_ms if move_delay_ms
    end

    # Tick wird in jedem update-Loop aufgerufen; gibt evtl. neuen game_state zurück
    def tick!(board, game_state)
      reset! unless defined?(@ai_for)

      side = side_to_move_from_state(game_state) # "white"/"black" oder nil
      return game_state unless side

      # Kommt die aktuelle Seite von der KI?
      return game_state unless @ai_for[side.to_sym]

      # Denkpause?
      now = Ai.now_ms
      return game_state if @busy || now < @next_think_at_ms

      @busy = true
      other = (side == "white" ? "black" : "white")

      # 1) besten Zug berechnen
      move = Ai.best_move(
        board, side,
        depth:        @depth[side.to_sym],
        time_limit_ms: @time_ms[side.to_sym]
      )

      if move
        figure_name = move[:figure].class.name.sub(/_.*/, '') # "Pawn_white" -> "Pawn"
        from_coords = move[:from]
        to_coords = move[:to]
        puts "KI (#{side}) zieht #{figure_name} von #{from_coords} nach #{to_coords}"
        # 2) anwenden
        Ai.make_move!(board, move)

        # 3) (optional) Auto-Promotion ohne UI
        maybe_auto_promote!(board, move, side)

        # 4) neuen State bestimmen (Check / Matt / Wechsel)
        game_state = next_state_after_ai_move(board, side, other)
      else
        # kein Zug (Patt oder Matt)
        game_state =
          if Ai.in_check?(board, side)
            side == "white" ? :check_mate_white : :check_mate_black
          else
            :stale_mate
          end
      end

      # kleine Denkpause bis zum nächsten KI-Zug
      @next_think_at_ms = Ai.now_ms + @move_delay_ms
      @busy = false
      game_state
    end

    # Sagt der main, ob Board-Klicks ignoriert werden sollen
    def ai_controls_turn?(game_state)
      side = side_to_move_from_state(game_state)
      side && @ai_for[side.to_sym]
    end

    # Public toggles (optional)
    def set_ai_for(side_sym, enabled)
      reset! unless defined?(@ai_for)
      @ai_for[side_sym] = !!enabled
    end

    def set_depth(side_sym, d)
      @depth[side_sym] = d
    end

    def set_time_ms(side_sym, ms)
      @time_ms[side_sym] = ms
    end

    # ------------------------------------------------------------
    private

    def side_to_move_from_state(state)
      case state
      when :white_turn then "white"
      when :black_turn then "black"
      else nil
      end
    end

    def maybe_auto_promote!(board, move, color_str)
      return unless move[:promotion]
      # Falls du bereits eine passende Methode hast, nutze sie:
      if defined?(Game_states) && Game_states.respond_to?(:auto_promote_to_queen!)
        Game_states.auto_promote_to_queen!(board, move[:to], color_str)
      else
        # Optional: hier später eigenen Promote-Helper aufrufen
      end
    end

    def next_state_after_ai_move(board, mover, opponent)
      if Ai.in_check?(board, opponent)
        opp_moves = Ai.generate_legal_moves(board, opponent)
        return (opponent == "white" ? :check_mate_white : :check_mate_black) if opp_moves.empty?
        return (opponent == "white" ? :check_white : :check_black)
      end
      opponent == "white" ? :white_turn : :black_turn
    end
  end
  reset!
end
